{"version":3,"sources":["../../lib/cluster/worker.ts"],"names":["globalSandbox","Worker","constructor","message","initialize","onInitialize","onExecute","sandboxOptions","create","wait","execute","queue","async","worker","Sandbox","sandbox","initialized","error","ex","name","stack","Promise","resolve","reject","check","setImmediate","code","timeout","globals","context","result","JSON","parse","process","send","on","push"],"mappings":"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","sourcesContent":["import Sandbox, { Options } from '../server/sandbox';\nimport async from 'async';\nimport assert from 'assert';\n\nlet globalSandbox = null;\n\ninterface Message {\n  initialize: boolean;\n  require?: string;\n  template?: string;\n  code?: string;\n  globals?: string;\n  context?: string;\n  timeout: number;\n}\n\nclass Worker {\n  queue: async.AsyncQueue<Message>;\n\n  sandboxOptions: Options;\n\n  sandbox: Sandbox;\n\n  initialized: boolean;\n\n  error: any;\n\n  constructor() {\n    this.queue = async.queue(this.worker, 1);\n  }\n\n  create() {\n    if (!globalSandbox) {\n      globalSandbox = new Sandbox(this.sandboxOptions);\n    }\n\n    this.sandbox = globalSandbox;\n    this.initialized = false;\n\n    return this.initialize();\n  }\n\n  async initialize() {\n    assert(!this.initialized);\n\n    try {\n      const { error } = await this.sandbox.initialize();\n\n      if (error) {\n        this.error = error;\n      }\n    } catch (ex) {\n      this.error = {\n        name: ex.name,\n        message: ex.message,\n        stack: ex.stack\n      };\n    }\n\n    this.initialized = true;\n  }\n\n  wait() {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        if (this.initialized) {\n          resolve();\n        } else {\n          setImmediate(check);\n        }\n      };\n\n      check();\n    });\n  }\n\n  async execute({ code, timeout, globals, context }: Message) {\n    assert(this.initialized);\n\n    let result;\n\n    if (!this.error) {\n      result = await this.sandbox.execute({\n        code,\n        timeout,\n        globals: JSON.parse(globals),\n        context: JSON.parse(context)\n      });\n    } else {\n      result = { error: this.error };\n    }\n\n    process.send(result);\n\n    // start creating the next sandbox *after* posting the completion message. This operation happens with coordination from\n    // the calling process, but that's OK because we wait for it's initialization.\n    setImmediate(() => {\n      this.create();\n    });\n  }\n\n  worker = async (message: Message) => {\n    if (message.initialize) {\n      await this.onInitialize(message);\n    } else {\n      await this.onExecute(message);\n    }\n  };\n\n  onInitialize = async (message: Message) => {\n    this.sandboxOptions = message;\n\n    await this.create();\n  };\n\n  onExecute = async (message: Message) => {\n    await this.wait();\n\n    await this.execute(message);\n  };\n}\n\nconst worker = new Worker();\n\nprocess.on('message', (message) => {\n  worker.queue.push(message);\n});\n"],"file":"worker.js"}