{"version":3,"sources":["../../lib/cluster/worker.js"],"names":["globalSandbox","Worker","constructor","message","initialize","onInitialize","onExecute","require","template","create","wait","global","context","JSON","parse","execute","code","queue","async","worker","id","process","argv","Sandbox","sandbox","initialized","error","ex","name","stack","Promise","resolve","reject","check","setImmediate","result","send","on","push","console","log","pid","shutdown","exit"],"mappings":"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","sourcesContent":["import Sandbox from '../server/sandbox';\nimport async from 'async';\nimport assert from 'assert';\n\nlet globalSandbox = null;\n\nclass Worker {\n  constructor()  {\n    this.queue = async.queue(this.worker, 1);\n  }\n\n  create() {\n    if (!globalSandbox) {\n      const id = `v8-sandbox-socket-${process.argv[2]}`;\n\n      globalSandbox = new Sandbox({ id, require: this.require, template: this.template });\n    }\n\n    this.sandbox = globalSandbox;\n    this.initialized = false;\n\n    return this.initialize();\n  }\n\n  async initialize() {\n    assert(!this.initialized);\n\n    try {\n      const { error } = await this.sandbox.initialize();\n\n      if (error) {\n        this.error = error;\n      }\n    } catch (ex) {\n      this.error = {\n        name: ex.name,\n        message: ex.message,\n        stack: ex.stack\n      };\n    }\n\n    this.initialized = true;\n  };\n\n  wait() {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        if (this.initialized) {\n          resolve();\n        } else {\n          setImmediate(check);\n        }\n      };\n\n      check();\n    });\n  }\n\n  async execute(code) {\n    assert(this.initialized);\n\n    let result;\n\n    if (!this.error)  {\n      result = await this.sandbox.execute({ code });\n    } else {\n      result = { error: this.error };\n    }\n\n    process.send(result);\n\n    // start creating the next sandbox *after* posting the completion message. This operation happens with coordination from\n    // the calling process, but that's OK because we wait for it's initialization.\n    setImmediate(() => { this.create(); });\n  }\n\n  worker = async (message) => {\n    if (message.initialize) {\n      await this.onInitialize(message);\n    } else {\n      await this.onExecute(message);\n    }\n  }\n\n  onInitialize = async (message) => {\n    this.require = message.require;\n    this.template = message.template;\n\n    await this.create();\n  }\n\n  onExecute = async (message) => {\n    await this.wait();\n\n    global.context = JSON.parse(message.context);\n\n    await this.execute(message.code);\n  }\n}\n\nconst worker = new Worker();\n\nprocess.on('message', (message) => {\n  worker.queue.push(message);\n});\n\nprocess.on('SIGTERM', function () {\n  if (globalSandbox) {\n    console.log('sigterm', process.pid);\n    globalSandbox.shutdown();\n    process.exit();\n  }\n});"],"file":"worker.js"}