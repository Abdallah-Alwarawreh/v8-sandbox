{"version":3,"sources":["../../lib/cluster/worker.js"],"names":["globalSandbox","Worker","constructor","message","initialize","onInitialize","onExecute","require","template","create","wait","execute","queue","async","worker","Sandbox","sandbox","initialized","error","ex","name","stack","Promise","resolve","reject","check","setImmediate","code","context","result","JSON","parse","process","send","on","push","shutdown","exit"],"mappings":"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","sourcesContent":["import Sandbox from '../server/sandbox';\nimport async from 'async';\nimport assert from 'assert';\n\nlet globalSandbox = null;\n\nclass Worker {\n  constructor() {\n    this.queue = async.queue(this.worker, 1);\n  }\n\n  create() {\n    if (!globalSandbox) {\n      globalSandbox = new Sandbox({ require: this.require, template: this.template });\n    }\n\n    this.sandbox = globalSandbox;\n    this.initialized = false;\n\n    return this.initialize();\n  }\n\n  async initialize() {\n    assert(!this.initialized);\n\n    try {\n      const { error } = await this.sandbox.initialize();\n\n      if (error) {\n        this.error = error;\n      }\n    } catch (ex) {\n      this.error = {\n        name: ex.name,\n        message: ex.message,\n        stack: ex.stack\n      };\n    }\n\n    this.initialized = true;\n  }\n\n  wait() {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        if (this.initialized) {\n          resolve();\n        } else {\n          setImmediate(check);\n        }\n      };\n\n      check();\n    });\n  }\n\n  async execute({ code, context }) {\n    assert(this.initialized);\n\n    let result;\n\n    if (!this.error) {\n      result = await this.sandbox.execute({ code, context: JSON.parse(context) });\n    } else {\n      result = { error: this.error };\n    }\n\n    process.send(result);\n\n    // start creating the next sandbox *after* posting the completion message. This operation happens with coordination from\n    // the calling process, but that's OK because we wait for it's initialization.\n    setImmediate(() => {\n      this.create();\n    });\n  }\n\n  worker = async (message) => {\n    if (message.initialize) {\n      await this.onInitialize(message);\n    } else {\n      await this.onExecute(message);\n    }\n  };\n\n  onInitialize = async (message) => {\n    this.require = message.require;\n    this.template = message.template;\n\n    await this.create();\n  };\n\n  onExecute = async (message) => {\n    await this.wait();\n\n    await this.execute(message);\n  };\n}\n\nconst worker = new Worker();\n\nprocess.on('message', (message) => {\n  worker.queue.push(message);\n});\n\nprocess.on('SIGTERM', () => {\n  if (globalSandbox) {\n    globalSandbox.shutdown();\n    process.exit();\n  }\n});\n"],"file":"worker.js"}