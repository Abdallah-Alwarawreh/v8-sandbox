{"version":3,"sources":["../../lib/cluster/worker.ts"],"names":["globalSandbox","Worker","constructor","message","initialize","onInitialize","onExecute","require","template","create","wait","execute","queue","async","worker","Sandbox","sandbox","initialized","error","ex","name","stack","Promise","resolve","reject","check","setImmediate","code","context","timeout","result","JSON","parse","process","send","on","push","shutdown","exit"],"mappings":"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","sourcesContent":["import Sandbox from '../server/sandbox';\nimport async from 'async';\nimport assert from 'assert';\n\nlet globalSandbox = null;\n\ninterface Message {\n  initialize: boolean;\n  require?: string;\n  template?: string;\n  code?: string;\n  context?: string;\n  timeout: string;\n}\n\nclass Worker {\n  require: string;\n\n  template: string;\n\n  queue: async.AsyncQueue<Message>;\n\n  sandbox: Sandbox;\n\n  initialized: boolean;\n\n  error: any;\n\n  constructor() {\n    this.queue = async.queue(this.worker, 1);\n  }\n\n  create() {\n    if (!globalSandbox) {\n      globalSandbox = new Sandbox({ require: this.require, template: this.template });\n    }\n\n    this.sandbox = globalSandbox;\n    this.initialized = false;\n\n    return this.initialize();\n  }\n\n  async initialize() {\n    assert(!this.initialized);\n\n    try {\n      const { error } = await this.sandbox.initialize();\n\n      if (error) {\n        this.error = error;\n      }\n    } catch (ex) {\n      this.error = {\n        name: ex.name,\n        message: ex.message,\n        stack: ex.stack\n      };\n    }\n\n    this.initialized = true;\n  }\n\n  wait() {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        if (this.initialized) {\n          resolve();\n        } else {\n          setImmediate(check);\n        }\n      };\n\n      check();\n    });\n  }\n\n  async execute({ code, context, timeout }: Message) {\n    assert(this.initialized);\n\n    let result;\n\n    if (!this.error) {\n      result = await this.sandbox.execute({ code, timeout, context: JSON.parse(context) });\n    } else {\n      result = { error: this.error };\n    }\n\n    process.send(result);\n\n    // start creating the next sandbox *after* posting the completion message. This operation happens with coordination from\n    // the calling process, but that's OK because we wait for it's initialization.\n    setImmediate(() => {\n      this.create();\n    });\n  }\n\n  worker = async (message: Message) => {\n    if (message.initialize) {\n      await this.onInitialize(message);\n    } else {\n      await this.onExecute(message);\n    }\n  };\n\n  onInitialize = async (message: Message) => {\n    this.require = message.require;\n    this.template = message.template;\n\n    await this.create();\n  };\n\n  onExecute = async (message: Message) => {\n    await this.wait();\n\n    await this.execute(message);\n  };\n}\n\nconst worker = new Worker();\n\nprocess.on('message', (message) => {\n  worker.queue.push(message);\n});\n\nprocess.on('SIGTERM', () => {\n  if (globalSandbox) {\n    globalSandbox.shutdown();\n    process.exit();\n  }\n});\n"],"file":"worker.js"}