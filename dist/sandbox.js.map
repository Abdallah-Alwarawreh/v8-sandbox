{"version":3,"sources":["../lib/sandbox.js"],"names":["NativeSandbox","require","Sandbox","nextObjectID","tryParseJSON","value","JSON","parse","ex","constructor","_native","id","terminate","callback","execute","code","json","result","error","Error","dispatch","bind","invocation","finish","err","results","serialized","message","length","push","apply","stringify","parameters","args","name","dispatchSync","dispatchAsync","httpRequest","log","console","options","response","body","Buffer","isBuffer","toString","slice","global","$exports"],"mappings":"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","file":"sandbox.js","sourcesContent":["const NativeSandbox = require('bindings')('sandbox').Sandbox;\n\nimport request from 'request';\n\nlet nextObjectID = 0;\n\nfunction tryParseJSON(value) {\n  try {\n    return JSON.parse(value);\n  } catch (ex) {\n    return null;\n  }\n}\n\nexport default class Sandbox {\n  constructor() {\n    this._native = new NativeSandbox();\n    this.id = ++nextObjectID;\n  }\n\n  terminate(callback) {\n    this._native.terminate(callback);\n  }\n\n  execute(code, callback) {\n    this._native.execute(code, (json) => {\n      let result = tryParseJSON(json);\n\n      if (result == null) {\n        result = { error: new Error('no result') };\n      }\n\n      callback(result.error, result.value);\n    }, this.dispatch.bind(this));\n  }\n\n  // handle function calls from the sandbox\n  dispatch(invocation) {\n    const finish = (err, ...results) => {\n      const serialized = [\n        err != null ? {message: err.message} : null\n      ];\n\n      if (results && results.length) {\n        serialized.push.apply(serialized, results);\n      }\n\n      invocation.callback(invocation, JSON.stringify(serialized));\n    };\n\n    const parameters = tryParseJSON(invocation.args);\n\n    if (parameters == null) {\n      return finish(new Error('invalid invocation parameters'));\n    }\n\n    if (invocation.name === 'dispatchSync') {\n      return this.dispatchSync(parameters, finish);\n    } else if (invocation.name === 'dispatchAsync') {\n      return this.dispatchAsync(parameters, finish);\n    } else if (invocation.name === 'httpRequest') {\n      return this.httpRequest(...parameters, finish);\n    } else if (invocation.name === 'log') {\n      this.log(...parameters);\n      return finish(null);\n    } else if (invocation.name === 'error') {\n      this.error(...parameters);\n      return finish(null);\n    }\n\n    return finish(null);\n  }\n\n  log(...args) {\n    console.log(...args);\n  }\n\n  error(...args) {\n    console.error(...args);\n  }\n\n  httpRequest(options, callback) {\n    request(options, (err, response, body) => {\n      if (Buffer.isBuffer(response.body)) {\n        response.body = body = response.body.toString('base64');\n      }\n\n      callback(err, response, body);\n    });\n  }\n\n  dispatchSync(args, callback) {\n    try {\n      const name = args[0];\n      const parameters = args.slice(1);\n\n      callback(null, global.$exports[name](...parameters));\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  dispatchAsync(args, callback) {\n    try {\n      const name = args[0];\n      const parameters = args.slice(1);\n\n      global.$exports[name](...[ ...parameters, callback ]);\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n"]}