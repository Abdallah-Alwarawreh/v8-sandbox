{"version":3,"sources":["../../lib/server/socket.ts"],"names":["tryParseJSON","value","JSON","parse","ex","Socket","EventEmitter","constructor","socket","sandbox","data","message","id","readInt32BE","length","json","toString","Buffer","byteLength","callback","args","isConnected","host","write","result","string","stringify","undefined","buffer","alloc","writeInt32BE","respond","fail","error","name","stack","Error","dispatch","console","resume","closed","state","worker","on","handleData","handleEnd","handleClose","handleError","handleDrain","shutdown","end","unref"],"mappings":"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","sourcesContent":["import EventEmitter from 'events';\nimport Sandbox from './sandbox';\nimport Worker from '../client/worker';\nimport net from 'net';\nimport { ChildProcess } from 'child_process';\n\nfunction tryParseJSON(value) {\n  try {\n    return JSON.parse(value);\n  } catch (ex) {\n    return null;\n  }\n}\n\ntype ReadState = 'idle' | 'reading';\n\ninterface Message {\n  id: number;\n  length: number;\n  json: string;\n}\n\nexport default class Socket extends EventEmitter {\n  sandbox: Sandbox;\n\n  worker: ChildProcess;\n\n  socket: net.Socket;\n\n  closed: boolean;\n\n  state: ReadState;\n\n  message: Message;\n\n  constructor(socket, sandbox) {\n    super();\n\n    this.state = 'idle';\n    this.sandbox = sandbox;\n    this.worker = sandbox.host.worker;\n    this.socket = socket;\n    this.socket.on('data', this.handleData);\n    this.socket.on('end', this.handleEnd);\n    this.socket.on('close', this.handleClose);\n    this.socket.on('error', this.handleError);\n    this.socket.on('drain', this.handleDrain);\n  }\n\n  shutdown() {\n    if (this.socket) {\n      this.closed = true;\n      this.socket.end();\n      this.socket.unref();\n    }\n  }\n\n  get isConnected() {\n    // make sure the current host is the host we started with. The host might've\n    // been replaced by the time this is invoked.\n    return !this.closed && this.worker === this.sandbox.host.worker;\n  }\n\n  handleFirstBuffer = (data) => {\n\n  };\n\n  handleLastBuffer = (data) => {\n\n  };\n\n  handleData = (data) => {\n    if (!this.message) {\n      this.message = {\n        id: data.readInt32BE(0),\n        length: data.readInt32BE(4),\n        json: data.toString('utf8', 8)\n      };\n    } else {\n      this.message.json += data.toString('utf8');\n    }\n\n    if (Buffer.byteLength(this.message.json) === this.message.length) {\n      const { id, json } = this.message;\n\n      this.message = null;\n\n      const message = tryParseJSON(json);\n\n      const callback = id > 0 && ((...args) => {\n        if (this.isConnected) {\n          this.sandbox.host.callback(id, args);\n        }\n      });\n\n      const write = (result) => {\n        const string = JSON.stringify({ id, result: result || { value: undefined } });\n        const length = Buffer.byteLength(string, 'utf8');\n        const buffer = Buffer.alloc(length + 4);\n\n        buffer.writeInt32BE(length);\n        buffer.write(string, 4);\n\n        if (this.isConnected) {\n          this.socket.write(buffer);\n        }\n      };\n\n      const respond = (value) => {\n        write({ value });\n      };\n\n      const fail = (error) => {\n        write({\n          error: {\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          }\n        });\n      };\n\n      try {\n        if (message == null) {\n          throw new Error('invalid dispatch');\n        }\n\n        this.sandbox.dispatch(message, { fail, respond, callback });\n      } catch (ex) {\n        fail(ex);\n      }\n    }\n  };\n\n  handleError = (error) => {\n    console.error('socket error', error);\n  };\n\n  handleDrain = () => {\n    this.socket.resume();\n  };\n\n  handleClose = () => {\n    this.closed = true;\n  };\n\n  handleEnd = () => {\n    this.closed = true;\n  };\n}\n"],"file":"socket.js"}