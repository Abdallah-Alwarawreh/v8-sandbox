{"version":3,"sources":["../../lib/server/socket.js"],"names":["tryParseJSON","value","JSON","parse","ex","Socket","EventEmitter","constructor","socket","sandbox","data","id","readInt32BE","json","toString","message","callback","args","worker","host","respond","result","stringify","length","Buffer","byteLength","buffer","alloc","writeInt32BE","write","Error","dispatch","error","name","stack","console","resume","on","handleData","handleError","handleDrain","shutdown","end","unref"],"mappings":"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","sourcesContent":["import EventEmitter from 'events';\n\nfunction tryParseJSON(value) {\n  try {\n    return JSON.parse(value);\n  } catch (ex) {\n    return null;\n  }\n}\n\nexport default class Socket extends EventEmitter {\n  constructor(socket, sandbox) {\n    super();\n\n    this.sandbox = sandbox;\n    this.worker = sandbox.host.worker;\n    this.socket = socket;\n    this.socket.on('data', this.handleData);\n    this.socket.on('error', this.handleError);\n    this.socket.on('drain', this.handleDrain);\n  }\n\n  shutdown() {\n    if (this.socket) {\n      this.socket.end();\n      this.socket.unref();\n    }\n  }\n\n  handleData = (data) => {\n    const id = data.readInt32BE();\n    const json = data.toString('utf8', 4);\n\n    const message = tryParseJSON(json);\n\n    const callback = (...args) => {\n      // make sure the current host is the host we started with. The host might've\n      // been replaced by the time this is invoked.\n      if (this.worker === this.sandbox.host.worker) {\n        this.sandbox.host.callback(id, args);\n      }\n    };\n\n    const respond = (result) => {\n      const json = JSON.stringify({ id, result: result || { value: null } });\n      const length = Buffer.byteLength(json, 'utf8');\n      const buffer = Buffer.alloc(length + 4);\n  \n      buffer.writeInt32BE(length);\n      buffer.write(json, 4);\n  \n      this.socket.write(buffer);\n    }\n\n    try {\n      if (message == null) {\n        throw new Error('invalid dispatch');\n      }\n\n      this.sandbox.dispatch(message, respond, callback);\n    } catch (ex) {\n      return respond({\n        error: {\n          name: ex.name,\n          message: ex.message,\n          stack: ex.stack\n        }\n      });\n    }\n  }\n\n  handleError = (error) => {\n    console.error('socket error', error);\n  }\n\n  handleDrain = () => {\n    this.socket.resume();\n  }\n}"],"file":"socket.js"}