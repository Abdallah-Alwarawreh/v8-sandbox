{"version":3,"sources":["../lib/worker.js"],"names":["global","$exports","globalSandbox","globalTemplate","AsyncSandbox","constructor","message","initialize","onInitialize","onExecute","require","Object","assign","template","create","wait","context","JSON","parse","execute","code","queue","async","worker","sandbox","Sandbox","initialized","result","Promise","resolve","reject","check","setImmediate","finalize","process","send","asyncSandbox","on","push"],"mappings":";;AAAA;;AACA;;AACA;;;;;;AAEAA,MAAM,CAACC,QAAP,GAAkB,EAAlB;AAEA,IAAIC,aAAa,GAAG,IAApB;AACA,IAAIC,cAAc,GAAG,IAArB;;AAEA,MAAMC,YAAN,CAAmB;AACjBC,EAAAA,WAAW,GAAI;AAAA,oCAmDN,MAAOC,OAAP,IAAmB;AAC1B,UAAIA,OAAO,CAACC,UAAZ,EAAwB;AACtB,cAAM,KAAKC,YAAL,CAAkBF,OAAlB,CAAN;AACD,OAFD,MAEO;AACL,cAAM,KAAKG,SAAL,CAAeH,OAAf,CAAN;AACD;AACF,KAzDc;;AAAA,0CA2DA,MAAOA,OAAP,IAAmB;AAChC,UAAIA,OAAO,CAACI,OAAZ,EAAqB;AACnBC,QAAAA,MAAM,CAACC,MAAP,CAAcZ,MAAM,CAACC,QAArB,EAA+BS,OAAO,CAACJ,OAAO,CAACI,OAAT,CAAtC;AACD;;AAED,WAAKG,QAAL,GAAiB,8BAA6BP,OAAO,CAACO,QAAR,IAAqB,EAAG,EAAtE;AAEA,YAAM,KAAKC,MAAL,EAAN;AACD,KAnEc;;AAAA,uCAqEH,MAAOR,OAAP,IAAmB;AAC7B,YAAM,KAAKS,IAAL,EAAN;AAEAf,MAAAA,MAAM,CAACgB,OAAP,GAAiBC,IAAI,CAACC,KAAL,CAAWZ,OAAO,CAACU,OAAnB,CAAjB;AAEA,YAAM,KAAKG,OAAL,CAAab,OAAO,CAACc,IAArB,CAAN;AACD,KA3Ec;;AACb,SAAKC,KAAL,GAAaC,eAAMD,KAAN,CAAY,KAAKE,MAAjB,EAAyB,CAAzB,CAAb;AACD;;AAEDT,EAAAA,MAAM,GAAG;AACP,SAAKU,OAAL,GAAe,IAAIC,gBAAJ,EAAf;AACA,SAAKC,WAAL,GAAmB,KAAnB;AAEA,WAAO,KAAKnB,UAAL,EAAP;AACD;;AAED,QAAMA,UAAN,GAAmB;AACjB,yBAAO,CAAC,KAAKmB,WAAb;AAEA,UAAM,KAAKF,OAAL,CAAajB,UAAb,EAAN;AAEA,UAAMoB,MAAM,GAAG,MAAM,KAAKH,OAAL,CAAaL,OAAb,CAAqB,KAAKN,QAA1B,CAArB;AAEA,SAAKa,WAAL,GAAmB,IAAnB;AAEA,WAAOC,MAAP;AACD;;AAEDZ,EAAAA,IAAI,GAAG;AACL,WAAO,IAAIa,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,YAAMC,KAAK,GAAG,MAAM;AAClB,YAAI,KAAKL,WAAT,EAAsB;AACpBG,UAAAA,OAAO;AACR,SAFD,MAEO;AACLG,UAAAA,YAAY,CAACD,KAAD,CAAZ;AACD;AACF,OAND;;AAQAA,MAAAA,KAAK;AACN,KAVM,CAAP;AAWD;;AAED,QAAMZ,OAAN,CAAcC,IAAd,EAAoB;AAClB,yBAAO,KAAKM,WAAZ;AAEA,UAAMC,MAAM,GAAG,MAAM,KAAKH,OAAL,CAAaL,OAAb,CAAqBC,IAArB,CAArB;AAEA,UAAM,KAAKI,OAAL,CAAaS,QAAb,EAAN;AAEAC,IAAAA,OAAO,CAACC,IAAR,CAAaR,MAAb,EAPkB,CASlB;AACA;;AACAK,IAAAA,YAAY,CAAC,MAAM;AAAE,WAAKlB,MAAL;AAAgB,KAAzB,CAAZ;AACD;;AAlDgB;;AA+EnB,MAAMsB,YAAY,GAAG,IAAIhC,YAAJ,EAArB;AAEA8B,OAAO,CAACG,EAAR,CAAW,SAAX,EAAuB/B,OAAD,IAAa;AACjC8B,EAAAA,YAAY,CAACf,KAAb,CAAmBiB,IAAnB,CAAwBhC,OAAxB;AACD,CAFD","sourcesContent":["import Sandbox from './sandbox';\nimport async from 'async';\nimport assert from 'assert';\n\nglobal.$exports = {};\n\nlet globalSandbox = null;\nlet globalTemplate = null;\n\nclass AsyncSandbox {\n  constructor()  {\n    this.queue = async.queue(this.worker, 1);\n  }\n\n  create() {\n    this.sandbox = new Sandbox();\n    this.initialized = false;\n\n    return this.initialize();\n  }\n\n  async initialize() {\n    assert(!this.initialized);\n\n    await this.sandbox.initialize();\n\n    const result = await this.sandbox.execute(this.template);\n\n    this.initialized = true;\n\n    return result;\n  };\n\n  wait() {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        if (this.initialized) {\n          resolve();\n        } else {\n          setImmediate(check);\n        }\n      };\n\n      check();\n    });\n  }\n\n  async execute(code) {\n    assert(this.initialized);\n\n    const result = await this.sandbox.execute(code);\n\n    await this.sandbox.finalize();\n\n    process.send(result);\n\n    // start creating the next sandbox *after* posting the completion message. This operation happens with coordination from\n    // the calling process, but that's OK because we wait for it's initialization.\n    setImmediate(() => { this.create(); });\n  }\n\n  worker = async (message) => {\n    if (message.initialize) {\n      await this.onInitialize(message);\n    } else {\n      await this.onExecute(message);\n    }\n  }\n\n  onInitialize = async (message) => {\n    if (message.require) {\n      Object.assign(global.$exports, require(message.require));\n    }\n\n    this.template = `setResult({value: null});\\n${message.template ||  ''}`;\n\n    await this.create();\n  }\n\n  onExecute = async (message) => {\n    await this.wait();\n\n    global.context = JSON.parse(message.context);\n\n    await this.execute(message.code);\n  }\n}\n\nconst asyncSandbox = new AsyncSandbox();\n\nprocess.on('message', (message) => {\n  asyncSandbox.queue.push(message);\n});\n"],"file":"worker.js"}