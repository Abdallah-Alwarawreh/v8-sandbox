{"version":3,"sources":["../lib/worker.js"],"names":["global","$exports","globalSandbox","AsyncSandbox","constructor","message","initialize","onInitialize","onExecute","require","template","create","wait","context","JSON","parse","execute","code","queue","async","worker","sandbox","Sandbox","initialized","ex","error","Promise","resolve","reject","check","setImmediate","result","finalize","process","send","asyncSandbox","on","push"],"mappings":"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","sourcesContent":["import Sandbox from './sandbox';\nimport async from 'async';\nimport assert from 'assert';\n\nglobal.$exports = {};\n\nlet globalSandbox = null;\n\nclass AsyncSandbox {\n  constructor()  {\n    this.queue = async.queue(this.worker, 1);\n  }\n\n  create() {\n    this.sandbox = new Sandbox({require: this.require, template: this.template});\n    this.initialized = false;\n\n    return this.initialize();\n  }\n\n  async initialize() {\n    assert(!this.initialized);\n\n    try {\n      await this.sandbox.initialize();\n    } catch (ex) {\n      ex.message = `error initializing sandbox. ${ex.message}`;\n\n      this.error = ex;\n    }\n\n    this.initialized = true;\n  };\n\n  wait() {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        if (this.initialized) {\n          resolve();\n        } else {\n          setImmediate(check);\n        }\n      };\n\n      check();\n    });\n  }\n\n  async execute(code) {\n    assert(this.initialized);\n\n    let result;\n\n    if (!this.error)  {\n      result = await this.sandbox.execute(code);\n    } else {\n      result = { error: this.error };\n    }\n\n    await this.sandbox.finalize();\n\n    process.send(result);\n\n    // start creating the next sandbox *after* posting the completion message. This operation happens with coordination from\n    // the calling process, but that's OK because we wait for it's initialization.\n    setImmediate(() => { this.create(); });\n  }\n\n  worker = async (message) => {\n    if (message.initialize) {\n      await this.onInitialize(message);\n    } else {\n      await this.onExecute(message);\n    }\n  }\n\n  onInitialize = async (message) => {\n    this.require = message.require;\n    this.template = message.template;\n\n    await this.create();\n  }\n\n  onExecute = async (message) => {\n    await this.wait();\n\n    global.context = JSON.parse(message.context);\n\n    await this.execute(message.code);\n  }\n}\n\nconst asyncSandbox = new AsyncSandbox();\n\nprocess.on('message', (message) => {\n  asyncSandbox.queue.push(message);\n});\n"],"file":"worker.js"}